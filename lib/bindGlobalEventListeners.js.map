{"version":3,"file":"bindGlobalEventListeners.js","sources":["../src-js/constants.js","../src-js/dom-utils.js","../src-js/bindGlobalEventListeners.js"],"sourcesContent":["export const ROUND_ARROW = '<svg width=\"16\" height=\"6\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z\"></svg>';\nexport const BOX_CLASS = `__NAMESPACE_PREFIX__-box`;\nexport const CONTENT_CLASS = `__NAMESPACE_PREFIX__-content`;\nexport const BACKDROP_CLASS = `__NAMESPACE_PREFIX__-backdrop`;\nexport const ARROW_CLASS = `__NAMESPACE_PREFIX__-arrow`;\nexport const SVG_ARROW_CLASS = `__NAMESPACE_PREFIX__-svg-arrow`;\nexport const TOUCH_OPTIONS = { passive: true, capture: true };\nexport const TIPPY_DEFAULT_APPEND_TO = () => document.body;\n","import { arrayFrom, isType, normalizeToArray, getBasePlacement } from './utils';\nexport function div() {\n    return document.createElement('div');\n}\nexport function isElement(value) {\n    return ['Element', 'Fragment'].some((type) => isType(value, type));\n}\nexport function isNodeList(value) {\n    return isType(value, 'NodeList');\n}\nexport function isMouseEvent(value) {\n    return isType(value, 'MouseEvent');\n}\nexport function isReferenceElement(value) {\n    return !!(value && value._tippy && value._tippy.reference === value);\n}\nexport function getArrayOfElements(value) {\n    if (isElement(value)) {\n        return [value];\n    }\n    if (isNodeList(value)) {\n        return arrayFrom(value);\n    }\n    if (Array.isArray(value)) {\n        return value;\n    }\n    return arrayFrom(document.querySelectorAll(value));\n}\nexport function setTransitionDuration(els, value) {\n    els.forEach((el) => {\n        if (el) {\n            el.style.transitionDuration = `${value}ms`;\n        }\n    });\n}\nexport function setVisibilityState(els, state) {\n    els.forEach((el) => {\n        if (el) {\n            el.setAttribute('data-state', state);\n        }\n    });\n}\nexport function getOwnerDocument(elementOrElements) {\n    var _a;\n    const [element] = normalizeToArray(elementOrElements);\n    // Elements created via a <template> have an ownerDocument with no reference to the body\n    return ((_a = element === null || element === void 0 ? void 0 : element.ownerDocument) === null || _a === void 0 ? void 0 : _a.body) ? element.ownerDocument : document;\n}\nexport function isCursorOutsideInteractiveBorder(popperTreeData, event) {\n    const { clientX, clientY } = event;\n    return popperTreeData.every(({ popperRect, popperState, props }) => {\n        const { interactiveBorder } = props;\n        const basePlacement = getBasePlacement(popperState.placement);\n        const offsetData = popperState.modifiersData.offset;\n        if (!offsetData) {\n            return true;\n        }\n        const topDistance = basePlacement === 'bottom' ? offsetData.top.y : 0;\n        const bottomDistance = basePlacement === 'top' ? offsetData.bottom.y : 0;\n        const leftDistance = basePlacement === 'right' ? offsetData.left.x : 0;\n        const rightDistance = basePlacement === 'left' ? offsetData.right.x : 0;\n        const exceedsTop = popperRect.top - clientY + topDistance > interactiveBorder;\n        const exceedsBottom = clientY - popperRect.bottom - bottomDistance > interactiveBorder;\n        const exceedsLeft = popperRect.left - clientX + leftDistance > interactiveBorder;\n        const exceedsRight = clientX - popperRect.right - rightDistance > interactiveBorder;\n        return exceedsTop || exceedsBottom || exceedsLeft || exceedsRight;\n    });\n}\nexport function updateTransitionEndListener(box, action, listener) {\n    const method = `${action}EventListener`;\n    // some browsers apparently support `transition` (unprefixed) but only fire\n    // `webkitTransitionEnd`...\n    ['transitionend', 'webkitTransitionEnd'].forEach((event) => {\n        box[method](event, listener);\n    });\n}\n/**\n * Compared to xxx.contains, this function works for dom structures with shadow\n * dom\n */\nexport function actualContains(parent, child) {\n    var _a, _b;\n    let target = child;\n    while (target) {\n        if (parent.contains(target)) {\n            return true;\n        }\n        target = (_b = (_a = target.getRootNode) === null || _a === void 0 ? void 0 : _a.call(target)) === null || _b === void 0 ? void 0 : _b.host;\n    }\n    return false;\n}\n","import { TOUCH_OPTIONS } from './constants';\nimport { isReferenceElement } from './dom-utils';\nexport const currentInput = { isTouch: false };\nlet lastMouseMoveTime = 0;\n/**\n * When a `touchstart` event is fired, it's assumed the user is using touch\n * input. We'll bind a `mousemove` event listener to listen for mouse input in\n * the future. This way, the `isTouch` property is fully dynamic and will handle\n * hybrid devices that use a mix of touch + mouse input.\n */\nexport function onDocumentTouchStart() {\n    if (currentInput.isTouch) {\n        return;\n    }\n    currentInput.isTouch = true;\n    if (window.performance) {\n        document.addEventListener('mousemove', onDocumentMouseMove);\n    }\n}\n/**\n * When two `mousemove` event are fired consecutively within 20ms, it's assumed\n * the user is using mouse input again. `mousemove` can fire on touch devices as\n * well, but very rarely that quickly.\n */\nexport function onDocumentMouseMove() {\n    const now = performance.now();\n    if (now - lastMouseMoveTime < 20) {\n        currentInput.isTouch = false;\n        document.removeEventListener('mousemove', onDocumentMouseMove);\n    }\n    lastMouseMoveTime = now;\n}\n/**\n * When an element is in focus and has a tippy, leaving the tab/window and\n * returning causes it to show again. For mouse users this is unexpected, but\n * for keyboard use it makes sense.\n * TODO: find a better technique to solve this problem\n */\nexport function onWindowBlur() {\n    const activeElement = document.activeElement;\n    if (isReferenceElement(activeElement)) {\n        const instance = activeElement._tippy;\n        if (activeElement.blur && !instance.state.isVisible) {\n            activeElement.blur();\n        }\n    }\n}\nexport default function bindGlobalEventListeners() {\n    document.addEventListener('touchstart', onDocumentTouchStart, TOUCH_OPTIONS);\n    window.addEventListener('blur', onWindowBlur);\n}\n"],"names":["TOUCH_OPTIONS","passive","capture","isReferenceElement","value","_tippy","reference","currentInput","isTouch","lastMouseMoveTime","onDocumentTouchStart","window","performance","document","addEventListener","onDocumentMouseMove","now","removeEventListener","onWindowBlur","activeElement","instance","blur","state","isVisible","bindGlobalEventListeners"],"mappings":";;;;;AAMO,IAAMA,aAAa,GAAG;AAAEC,EAAAA,OAAO,EAAE,IAAX;AAAiBC,EAAAA,OAAO,EAAE;AAA1B,CAAtB;;ACOA,SAASC,kBAAT,CAA4BC,KAA5B,EAAmC;AACtC,SAAO,CAAC,EAAEA,KAAK,IAAIA,KAAK,CAACC,MAAf,IAAyBD,KAAK,CAACC,MAAN,CAAaC,SAAb,KAA2BF,KAAtD,CAAR;AACH;;ICbYG,YAAY,GAAG;AAAEC,EAAAA,OAAO,EAAE;AAAX,CAArB;AACP,IAAIC,iBAAiB,GAAG,CAAxB;AACA;;;;;;;AAMA,AAAO,SAASC,oBAAT,GAAgC;AACnC,MAAIH,YAAY,CAACC,OAAjB,EAA0B;AACtB;AACH;;AACDD,EAAAA,YAAY,CAACC,OAAb,GAAuB,IAAvB;;AACA,MAAIG,MAAM,CAACC,WAAX,EAAwB;AACpBC,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,WAA1B,EAAuCC,mBAAvC;AACH;AACJ;AACD;;;;;;AAKA,AAAO,SAASA,mBAAT,GAA+B;AAClC,MAAMC,GAAG,GAAGJ,WAAW,CAACI,GAAZ,EAAZ;;AACA,MAAIA,GAAG,GAAGP,iBAAN,GAA0B,EAA9B,EAAkC;AAC9BF,IAAAA,YAAY,CAACC,OAAb,GAAuB,KAAvB;AACAK,IAAAA,QAAQ,CAACI,mBAAT,CAA6B,WAA7B,EAA0CF,mBAA1C;AACH;;AACDN,EAAAA,iBAAiB,GAAGO,GAApB;AACH;AACD;;;;;;;AAMA,AAAO,SAASE,YAAT,GAAwB;AAC3B,MAAMC,aAAa,GAAGN,QAAQ,CAACM,aAA/B;;AACA,MAAIhB,kBAAkB,CAACgB,aAAD,CAAtB,EAAuC;AACnC,QAAMC,QAAQ,GAAGD,aAAa,CAACd,MAA/B;;AACA,QAAIc,aAAa,CAACE,IAAd,IAAsB,CAACD,QAAQ,CAACE,KAAT,CAAeC,SAA1C,EAAqD;AACjDJ,MAAAA,aAAa,CAACE,IAAd;AACH;AACJ;AACJ;AACD,AAAe,SAASG,wBAAT,GAAoC;AAC/CX,EAAAA,QAAQ,CAACC,gBAAT,CAA0B,YAA1B,EAAwCJ,oBAAxC,EAA8DV,aAA9D;AACAW,EAAAA,MAAM,CAACG,gBAAP,CAAwB,MAAxB,EAAgCI,YAAhC;AACH;;;;;"}